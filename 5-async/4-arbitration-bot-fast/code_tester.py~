import unittest
from unittest.mock import AsyncMock, Mock, patch, mock_open
from parameterized import parameterized
import asyncio
import aiohttp
from aiohttp import ClientResponseError, ClientConnectionError
from api_module import OkxAPI, HTTPError, ExchangeAPIError, dump_json_to_file  # Замените 'api_module' на имя вашего файла


class OkxAPIMock(OkxAPI):
    """Подкласс для фиктивной реализации абстрактного класса OkxAPI"""
    async def request_ticker_data(self, ticker):
        pass

    async def get_price_from_request(self, ticker):
        pass


class TestOkxAPI(unittest.IsolatedAsyncioTestCase):
    async def asyncSetUp(self):
        self.api = OkxAPIMock()
        await self.api.__aenter__()

    async def asyncTearDown(self):
        await self.api.__aexit__(None, None, None)

    @parameterized.expand([
        (400, "❌ Ошибка 400: Неверный запрос. Проверьте корректность параметров запроса."),
        (401, "❌ Ошибка 401: Неавторизованный доступ. Проверьте токен или учетные данные."),
        (403, "❌ Ошибка 403: Доступ запрещён. У вас нет прав для доступа к этому ресурсу."),
        (404, "❌ Ошибка 404: Ресурс не найден. Проверьте правильность URL."),
        (405, "❌ Ошибка 405: Метод не поддерживается. Проверьте HTTP-метод запроса."),
        (408, "❌ Ошибка 408: Время ожидания запроса истекло. Попробуйте снова."),
        (429, "❌ Ошибка 429: Превышено количество запросов. Попробуйте уменьшить частоту запросов."),
        (500, "❌ Ошибка 500: Внутренняя ошибка сервера. Попробуйте снова позже."),
        (501, "❌ Ошибка 501: Метод не реализован. Сервер не поддерживает запрошенный метод."),
        (502, "❌ Ошибка 502: Плохой шлюз. Сервер получил неверный ответ от вышестоящего сервера."),
        (503, "❌ Ошибка 503: Сервис временно недоступен. Сервер перегружен или на обслуживании."),
        (504, "❌ Ошибка 504: Время ожидания шлюза истекло. Вышестоящий сервер не ответил вовремя."),
    ])
    @patch("aiohttp.ClientSession.get")
    async def test_http_errors(self, status_code, expected_message, mock_get):
        """Параметризованный тест для проверки различных HTTP ошибок"""
        mock_response = Mock()
        mock_response.raise_for_status.side_effect = ClientResponseError(
            request_info=None, history=(), status=status_code
        )
        mock_response.json = AsyncMock(return_value={})
        mock_get.return_value.__aenter__.return_value = mock_response

        with self.assertRaises(HTTPError) as context:
            await self.api.request_spot_data()

        self.assertEqual(expected_message, str(context.exception))

    @patch("aiohttp.ClientSession.get")
    async def test_json_decode_error(self, mock_get):
        """Тестирует обработку ошибки декодирования JSON"""
        mock_response = Mock()
        mock_response.raise_for_status.return_value = None
        mock_response.json = AsyncMock(side_effect=ValueError("JSON decode error"))
        mock_get.return_value.__aenter__.return_value = mock_response

        with self.assertRaises(ExchangeAPIError) as context:
            await self.api.request_spot_data()

        self.assertIn("Ошибка при обработке JSON", str(context.exception))

    @patch("aiohttp.ClientSession.get")
    async def test_connection_error(self, mock_get):
        """Тестирует обработку ошибки соединения"""
        mock_get.side_effect = ClientConnectionError("Connection error")

        with self.assertRaises(ExchangeAPIError) as context:
            await self.api.request_spot_data()

        self.assertIn("Ошибка запроса", str(context.exception))

    @patch("aiohttp.ClientSession.get")
    async def test_timeout_error(self, mock_get):
        """Тестирует обработку ошибки таймаута"""
        mock_get.side_effect = asyncio.TimeoutError("Timeout error")

        with self.assertRaises(ExchangeAPIError) as context:
            await self.api.request_spot_data()

        self.assertIn("Ошибка запроса", str(context.exception))

    @patch("aiohttp.ClientSession.get")
    async def test_client_os_error(self, mock_get):
        """Тестирует обработку сетевой ошибки ClientOSError"""
        mock_get.side_effect = aiohttp.ClientOSError("Client OS error")

        with self.assertRaises(ExchangeAPIError) as context:
            await self.api.request_spot_data()

        self.assertIn("Ошибка запроса", str(context.exception))

    @patch("aiohttp.ClientSession.get")
    async def test_client_payload_error(self, mock_get):
        """Тестирует обработку ошибки ClientPayloadError"""
        mock_response = Mock()
        mock_response.raise_for_status.return_value = None
        mock_response.json = AsyncMock(side_effect=aiohttp.ClientPayloadError("Payload error"))
        mock_get.return_value.__aenter__.return_value = mock_response

        with self.assertRaises(ExchangeAPIError) as context:
            await self.api.request_spot_data()

        self.assertIn("Ошибка запроса", str(context.exception))

    @patch("aiohttp.ClientSession.get")
    async def test_server_disconnected_error(self, mock_get):
        """Тестирует обработку ошибки ServerDisconnectedError"""
        mock_get.side_effect = aiohttp.ServerDisconnectedError("Server disconnected")

        with self.assertRaises(ExchangeAPIError) as context:
            await self.api.request_spot_data()

        self.assertIn("Ошибка запроса", str(context.exception))

    @patch("aiohttp.ClientSession.get")
    async def test_client_ssl_error(self, mock_get):
        """Тестирует обработку ошибки ClientSSLError"""
        mock_get.side_effect = aiohttp.ClientSSLError("SSL error")

        with self.assertRaises(ExchangeAPIError) as context:
            await self.api.request_spot_data()

        self.assertIn("Ошибка запроса", str(context.exception))

    @patch("aiofiles.open", new_callable=mock_open)
    async def test_file_not_found_error(self, mock_file):
        """Тестирует обработку FileNotFoundError при записи JSON файла"""
        mock_file.side_effect = FileNotFoundError("File not found error")

        result = await dump_json_to_file({"test": "data"}, "invalid_path.json")

        self.assertFalse(result)

    @patch("aiofiles.open", new_callable=mock_open)
    async def test_io_error_on_file_write(self, mock_file):
        """Тестирует обработку ошибок ввода/вывода при записи JSON файла"""
        mock_file.side_effect = OSError("I/O error")

        result = await dump_json_to_file({"test": "data"}, "invalid_path.json")

        self.assertFalse(result)


if __name__ == "__main__":
    unittest.main()
